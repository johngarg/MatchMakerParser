* MatchMakerParser

A small tool to parse Mathematica expressions from MatchMaker into Python code.

** Questions
- What do we do about input parameters and running?
- The way MatchMaker is dealing with complex conjugates is a bit annoying,
  haven't thought a lot about what to do here

** Workflow
How do we want this to work? Last meeting we discussed an output like:
#+begin_src python
matching_instance = MatchingResults(scale=1000, yLQ=np.matrix([[1, 7j, 0],[...],[...]]), ...)
matching_instance.get_coeff("Clq(1)", [1,1,1,1])
#+end_src
This means that nothing will need to be symbolic within the dataclass. Initialise the objects with sensible values so that only the matrix will need to be updated.

Another idea is to just treat everything that's symbolic in the Mathematica code as symbolic in Python with Sympy:
#+begin_src Mathematica
StringRiffle[
 Table[ToString[i] <> " = Symbol(" <> PythonForm[ToString[i]] <>
   ")", {i, Normal @ $PythonForm`Symbols}], "\n"]
#+end_src
Will give something like
#+begin_src python
ydbar = Symbol('ydbar')
μ = Symbol('μ')
MS1 = Symbol('MS1')
YLQS = Symbol('YLQS')
YLQSbar = Symbol('YLQSbar')
#+end_src
In any case, we can use a version of this to add the additional symbols as attributes to the class.

** Thoughts on a Numpy interface

There is an idea to actually use =numpy= to perform fast matrix multiplication,
since =sympy= can recognise matrix summations:
#+begin_src python
import sympy as sym
import numpy as np
from numpy import dot

from sympy.abc import i,j,k,l

X = sym.MatrixSymbol("X", 2, 2)
matrix_expr = sym.MatrixExpr.from_index_summation(sym.Sum(X[i,j]*X[i,k], (i, 0, 1)))
func = sym.lambdify(X, matrix_expr, modules='numpy')

npX = np.matrix([[1, 2], [3, 4]])
func(npX)
#+end_src
It's not clear if this will be quicker than just using =Sympy= to perform the matrix multiplication, or just the sum directly using =summation= for that matter!
